//-------------------------------------------------------------------------------------------------
// <auto-generated> 
// Marked as auto-generated so StyleCop will ignore BDD style tests
// </auto-generated>
//-------------------------------------------------------------------------------------------------
#pragma warning disable 169
// ReSharper disable InconsistentNaming
// ReSharper disable UnusedMember.Global
// ReSharper disable UnusedMember.Local

namespace RedBadger.Xpf.Specs.Presentation
{
    using System;

    using Xpf.Presentation;

    using Machine.Specifications;

    using Rhino.Mocks;

    public abstract class a_UIElement
    {
        protected static UIElement uiElement;

        private Establish context = () => uiElement = MockRepository.GenerateStub<UIElement>();
    }

    [Subject(typeof(UIElement), "Measuring")]
    public class when_the_supplied_available_size_Width_is_not_a_number : a_UIElement
    {
        private static Exception exception;

        private Because of = () => exception = Catch.Exception(() => uiElement.Measure(new Size(double.NaN, 0)));

        private It should_throw_a_Exception =
            () => exception.ShouldBeOfType<InvalidOperationException>();
    }
    
    [Subject(typeof(UIElement), "Measuring")]
    public class when_the_supplied_available_size_Height_is_not_a_number : a_UIElement
    {
        private static Exception exception;

        private Because of = () => exception = Catch.Exception(() => uiElement.Measure(new Size(0, double.NaN)));

        private It should_throw_a_Exception =
            () => exception.ShouldBeOfType<InvalidOperationException>();
    }

    [Subject(typeof(UIElement), "Measure")]
    public class when_measuring : a_UIElement
    {
        private static readonly Size availableSize = new Size(10, 10);

        private static readonly Size expectedDesiredSize = new Size(5, 5);

        private Establish context = () => uiElement.Expect(element => element.MeasureOverride(availableSize)).Return(new Size(5, 5));

        private Because of = () => uiElement.Measure(availableSize);

        private It should_invalidate_arrange = () => uiElement.IsArrangeValid.ShouldBeFalse();

        private It should_be_marked_as_having_a_valid_Measure = () => uiElement.IsMeasureValid.ShouldBeTrue();

        private It should_have_a_desired_size_set = () => uiElement.DesiredSize.ShouldEqual(expectedDesiredSize);
    }

    [Subject(typeof(UIElement), "Measure")]
    public class when_an_implementing_control_returns_a_size_greater_than_the_available_size : a_UIElement
    {
        private static readonly Size availableSize = new Size(10, 10);

        private Establish context =
            () => uiElement.Expect(element => element.MeasureOverride(availableSize)).Return(new Size(95, 100));

        private Because of = () => uiElement.Measure(availableSize);

        private It should_reduce_the_size_returned_to_keep_it_within_the_available_size_passed_to_Measure =
            () => uiElement.DesiredSize.ShouldEqual(availableSize);
    }

    [Subject(typeof(UIElement), "Measure")]
    public class when_the_implementing_controls_requested_size_combined_with_the_margin_exceeds_the_available_size : a_UIElement
    {
        private static readonly Size availableSize = new Size(10, 10);

        private Establish context =
            () =>
                {
                    uiElement.Margin = new Thickness(10, 20, 30, 40);
                    uiElement.Expect(element => element.MeasureOverride(availableSize)).IgnoreArguments().Return(new Size(5, 5));
                };

        private Because of = () => uiElement.Measure(availableSize);

        private It should_reduce_the_size_returned_to_keep_it_within_the_available_size_passed_to_Measure =
            () => uiElement.DesiredSize.ShouldEqual(availableSize);
    }

    [Subject(typeof(UIElement), "Measuring")]
    public class when_an_implementing_control_returns_a_negative_size : a_UIElement
    {
        private static readonly Size availableSize = new Size(10, 10);

        private Establish context =
            () => uiElement.Expect(element => element.MeasureOverride(availableSize)).Return(new Size(-10, -10));

        private Because of = () => uiElement.Measure(availableSize);

        private It should_return_a_zero_value_instead = () => uiElement.DesiredSize.ShouldEqual(Size.Empty);
    }

    [Subject(typeof(UIElement), "Measure")]
    public class when_an_implementing_control_returns_a_width_of_positive_infinity : a_UIElement
    {
        private static Exception exception;

        private static readonly Size availableSize = new Size(double.PositiveInfinity, double.PositiveInfinity);

        private Establish context =
            () =>
            uiElement.Expect(element => element.MeasureOverride(availableSize)).Return(
                new Size(double.PositiveInfinity, 0));

        private Because of = () => exception = Catch.Exception(() => uiElement.Measure(availableSize));

        private It should_throw_an_exception = () => exception.ShouldBeOfType<InvalidOperationException>();
    }

    [Subject(typeof(UIElement), "Measure")]
    public class when_an_implementing_control_returns_a_height_of_positive_infinity : a_UIElement
    {
        private static Exception exception;

        private static readonly Size availableSize = new Size(double.PositiveInfinity, double.PositiveInfinity);

        private Establish context =
            () =>
            uiElement.Expect(element => element.MeasureOverride(availableSize)).Return(
                new Size(0, double.PositiveInfinity));

        private Because of = () => exception = Catch.Exception(() => uiElement.Measure(availableSize));

        private It should_throw_an_exception = () => exception.ShouldBeOfType<InvalidOperationException>();
    }

    [Subject(typeof(UIElement), "Measure")]
    public class when_an_implementing_control_returns_a_width_that_is_not_a_number : a_UIElement
    {
        private static Exception exception;

        private static readonly Size availableSize = new Size(double.PositiveInfinity, double.PositiveInfinity);

        private Establish context =
            () =>
            uiElement.Expect(element => element.MeasureOverride(availableSize)).Return(
                new Size(double.NaN, 0));

        private Because of = () => exception = Catch.Exception(() => uiElement.Measure(availableSize));

        private It should_throw_an_exception = () => exception.ShouldBeOfType<InvalidOperationException>();
    }

    [Subject(typeof(UIElement), "Measure")]
    public class when_an_implementing_control_returns_a_height_that_is_not_a_number : a_UIElement
    {
        private static Exception exception;

        private static readonly Size availableSize = new Size(double.PositiveInfinity, double.PositiveInfinity);

        private Establish context =
            () =>
            uiElement.Expect(element => element.MeasureOverride(availableSize)).Return(
                new Size(0, double.NaN));

        private Because of = () => exception = Catch.Exception(() => uiElement.Measure(availableSize));

        private It should_throw_an_exception = () => exception.ShouldBeOfType<InvalidOperationException>();
    }

    [Subject(typeof(UIElement), "Measure")]
    public class when_an_implementing_control_is_asked_to_measure_itself : a_UIElement
    {
        private static Size availableSize = new Size(400, 300);

        private static readonly Thickness margin = new Thickness(10, 20, 30, 40);

        private Establish context = () => uiElement.Margin = margin;

        private Because of = () => uiElement.Measure(availableSize);

        private It should_be_given_an_available_size_that_does_not_include_margins = () =>
                                                                                         {
                                                                                             var expectedAvailableSize =
                                                                                                 new Size(
                                                                                                     availableSize.Width -
                                                                                                     (margin.Left +
                                                                                                      margin.Right),
                                                                                                     availableSize.
                                                                                                         Height -
                                                                                                     (margin.Top +
                                                                                                      margin.Bottom));

                                                                                             uiElement.AssertWasCalled(
                                                                                                 element =>
                                                                                                 element.
                                                                                                     MeasureOverride(
                                                                                                         expectedAvailableSize));
                                                                                         };
    }

    [Subject(typeof(UIElement), "Measure")]
    public class after_measure_is_called : a_UIElement
    {
        private Establish context = () => uiElement.Measure(Size.Empty);

        private Because of = () => uiElement.Measure(Size.Empty);

        private It should_be_considered_valid = () => uiElement.IsMeasureValid.ShouldBeTrue();

        private It should_not_measure_again =
            () => uiElement.AssertWasCalled(element => element.MeasureOverride(Size.Empty), element => element.Repeat.Once());
    }

    internal static class UIElementMockingExtensions
    {
        public static Size MeasureOverride(this UIElement element, Size availableSize)
        {
            var result =
                typeof(UIElement).GetMethod(
                    "MeasureOverride",
                    System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic,
                    null,
                    new[] { typeof(Size) },
                    null).Invoke(element, new object[] { availableSize });

            return (Size)result;
        }
    }
}