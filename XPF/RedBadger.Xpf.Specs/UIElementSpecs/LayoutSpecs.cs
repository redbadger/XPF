#region License
/* The MIT License
 *
 * Copyright (c) 2011 Red Badger Consulting
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
*/
#endregion

//-------------------------------------------------------------------------------------------------
// <auto-generated> 
// Marked as auto-generated so StyleCop will ignore BDD style tests
// </auto-generated>
//-------------------------------------------------------------------------------------------------

#pragma warning disable 169
// ReSharper disable InconsistentNaming
// ReSharper disable UnusedMember.Global
// ReSharper disable UnusedMember.Local

namespace RedBadger.Xpf.Specs.UIElementSpecs
{
    using Machine.Specifications;

    using Moq;
    using Moq.Protected;

    using It = Machine.Specifications.It;

    [Subject(typeof(UIElement), "Layout - explicit sizes")]
    public class when_an_explicit_size_is_set : a_UIElement
    {
        private static readonly Size availableSize = new Size(300, 300);

        private static readonly Size explicitSize = new Size(100, 100);

        private Because of = () =>
            {
                Subject.Object.Width = explicitSize.Width;
                Subject.Object.Height = explicitSize.Height;
                Subject.Object.Measure(availableSize);
            };

        private It should_measure_its_children_with_that_size =
            () =>
            Subject.Protected().Verify(
                MeasureOverride, Times.Once(), ItExpr.Is<Size>(size => size.Equals(explicitSize)));
    }

    [Subject(typeof(UIElement), "Layout - explicit sizes")]
    public class when_an_explicit_size_is_set_and_the_children_want_less_space : a_UIElement_in_a_RootElement
    {
        private static readonly Size availableSize = new Size(300, 300);

        private static readonly Size desiredSize = new Size(50, 50);

        private static readonly Vector expectedVisualOffset = new Vector(125, 125);

        private static readonly Size explicitSize = new Size(100, 100);

        private Establish context = () =>
            {
                Subject.Protected().Setup<Size>(MeasureOverride, ItExpr.IsAny<Size>()).Returns(desiredSize);
                Subject.Protected().Setup<Size>(ArrangeOverride, ItExpr.IsAny<Size>()).Returns(desiredSize);
            };

        private Because of = () =>
            {
                Subject.Object.Width = explicitSize.Width;
                Subject.Object.Height = explicitSize.Height;
                Subject.Object.Measure(availableSize);
                Subject.Object.Arrange(new Rect(availableSize));
            };

        private It should_arrange_its_children_within_the_explicit_size =
            () =>
            Subject.Protected().Verify(
                ArrangeOverride, Times.Once(), ItExpr.Is<Size>(size => size.Equals(explicitSize)));

        private It should_have_a_desired_size_equal_to_the_size_that_was_specified =
            () => Subject.Object.DesiredSize.ShouldEqual(explicitSize);

        private It should_have_the_correct_visual_offset =
            () => Subject.Object.VisualOffset.ShouldEqual(expectedVisualOffset);

        private It should_not_clip =
            () => Subject.Object.ClippingRect.ShouldEqual(Rect.Empty);
    }

    [Subject(typeof(UIElement), "Layout - explicit sizes")]
    public class when_an_explicit_size_is_set_and_the_children_want_more_space : a_UIElement_in_a_RootElement
    {
        private static readonly Size availableSize = new Size(300, 300);

        private static readonly Size desiredSize = new Size(200, 200);

        private static readonly Vector expectedVisualOffset = new Vector(100, 100);

        private static readonly Size explicitSize = new Size(100, 100);

        private Establish context = () =>
            {
                Subject.Protected().Setup<Size>(MeasureOverride, ItExpr.IsAny<Size>()).Returns(desiredSize);
                Subject.Protected().Setup<Size>(ArrangeOverride, ItExpr.IsAny<Size>()).Returns(desiredSize);
            };

        private Because of = () =>
            {
                Subject.Object.Width = explicitSize.Width;
                Subject.Object.Height = explicitSize.Height;
                Subject.Object.Measure(availableSize);
                Subject.Object.Arrange(new Rect(availableSize));
            };

        private It should_arrange_its_children_within_the_unclipped_desired_size =
            () =>
            Subject.Protected().Verify(ArrangeOverride, Times.Once(), ItExpr.Is<Size>(size => size.Equals(desiredSize)));

        private It should_clip =
            () => Subject.Object.ClippingRect.ShouldEqual(new Rect(explicitSize));

        private It should_have_a_desired_size_equal_to_the_size_that_was_specified =
            () => Subject.Object.DesiredSize.ShouldEqual(explicitSize);

        private It should_have_the_correct_visual_offset =
            () => Subject.Object.VisualOffset.ShouldEqual(expectedVisualOffset);
    }

    [Subject(typeof(UIElement), "Layout - explicit sizes")]
    public class when_a_minimum_size_is_set_and_the_children_want_less_space : a_UIElement_in_a_RootElement
    {
        private static readonly Size availableSize = new Size(300, 300);

        private static readonly Size desiredSize = new Size(50, 50);

        private static readonly Vector expectedVisualOffset = new Vector(125, 125);

        private static readonly Size minimumSize = new Size(100, 100);

        private Establish context = () =>
            {
                Subject.Protected().Setup<Size>(MeasureOverride, ItExpr.IsAny<Size>()).Returns(desiredSize);
                Subject.Protected().Setup<Size>(ArrangeOverride, ItExpr.IsAny<Size>()).Returns(desiredSize);
            };

        private Because of = () =>
            {
                Subject.Object.MinWidth = minimumSize.Width;
                Subject.Object.MinHeight = minimumSize.Height;
                Subject.Object.Measure(availableSize);
                Subject.Object.Arrange(new Rect(availableSize));
            };

        private It should_arrange_its_children_within_the_available_size =
            () =>
            Subject.Protected().Verify(
                ArrangeOverride, Times.Once(), ItExpr.Is<Size>(size => size.Equals(availableSize)));

        private It should_have_a_desired_size_equal_to_the_minimum_size_that_was_specified =
            () => Subject.Object.DesiredSize.ShouldEqual(minimumSize);

        private It should_have_the_correct_visual_offset =
            () => Subject.Object.VisualOffset.ShouldEqual(expectedVisualOffset);

        private It should_not_clip =
            () => Subject.Object.ClippingRect.ShouldEqual(Rect.Empty);
    }

    [Subject(typeof(UIElement), "Layout - explicit sizes")]
    public class when_a_maximum_size_is_set_and_the_children_want_more_space : a_UIElement_in_a_RootElement
    {
        private static readonly Size availableSize = new Size(300, 300);

        private static readonly Size desiredSize = new Size(200, 200);

        private static readonly Vector expectedVisualOffset = new Vector(100, 100);

        private static readonly Size maximumSize = new Size(100, 100);

        private Establish context = () =>
            {
                Subject.Protected().Setup<Size>(MeasureOverride, ItExpr.IsAny<Size>()).Returns(desiredSize);
                Subject.Protected().Setup<Size>(ArrangeOverride, ItExpr.IsAny<Size>()).Returns(desiredSize);
            };

        private Because of = () =>
            {
                Subject.Object.MaxWidth = maximumSize.Width;
                Subject.Object.MaxHeight = maximumSize.Height;
                Subject.Object.Measure(availableSize);
                Subject.Object.Arrange(new Rect(availableSize));
            };

        private It should_arrange_its_children_within_the_unclipped_desired_size =
            () =>
            Subject.Protected().Verify(ArrangeOverride, Times.Once(), ItExpr.Is<Size>(size => size.Equals(desiredSize)));

        private It should_clip =
            () => Subject.Object.ClippingRect.ShouldEqual(new Rect(maximumSize));

        private It should_have_a_desired_size_equal_to_the_maximum_size_that_was_specified =
            () => Subject.Object.DesiredSize.ShouldEqual(maximumSize);

        private It should_have_the_correct_visual_offset =
            () => Subject.Object.VisualOffset.ShouldEqual(expectedVisualOffset);
    }

    [Subject(typeof(UIElement), "Layout - Invalidate")]
    public class when_measure_is_invalidated : a_Measured_and_Arranged_UIElement
    {
        private Establish context = () =>
            {
                var parentUiElement = new Mock<UIElement>();
                parentUiElement.Object.Measure(Size.Empty);
                parentUiElement.Object.Arrange(Rect.Empty);

                Subject.Object.VisualParent = parentUiElement.Object;
            };

        private Because of = () => Subject.Object.InvalidateMeasure();

        private It should_invalidate_arrange = () => Subject.Object.IsArrangeValid.ShouldBeFalse();

        private It should_invalidate_its_parents_arrange =
            () => Subject.Object.VisualParent.IsArrangeValid.ShouldBeFalse();

        private It should_invalidate_its_parents_measure =
            () => Subject.Object.VisualParent.IsMeasureValid.ShouldBeFalse();

        private It should_invalidate_measure = () => Subject.Object.IsMeasureValid.ShouldBeFalse();
    }

    [Subject(typeof(UIElement), "Layout - Invalidate")]
    public class when_arrange_is_invalidated : a_Measured_and_Arranged_UIElement
    {
        private Establish context = () =>
            {
                var parentUiElement = new Mock<UIElement>();
                parentUiElement.Object.Measure(Size.Empty);
                parentUiElement.Object.Arrange(Rect.Empty);

                Subject.Object.VisualParent = parentUiElement.Object;
            };

        private Because of = () => Subject.Object.InvalidateArrange();

        private It should_invalidate_arrange = () => Subject.Object.IsArrangeValid.ShouldBeFalse();

        private It should_invalidate_its_parents_arrange =
            () => Subject.Object.VisualParent.IsArrangeValid.ShouldBeFalse();

        private It should_not_invalidate_its_parents_measure =
            () => Subject.Object.VisualParent.IsMeasureValid.ShouldBeTrue();

        private It should_not_invalidate_measure = () => Subject.Object.IsMeasureValid.ShouldBeTrue();
    }

    [Subject(typeof(UIElement), "Layout - Invalidate")]
    public class when_height_is_changed : a_Measured_and_Arranged_UIElement
    {
        private Because of = () => Subject.Object.Height = 100;

        private It should_invalidate_arrange = () => Subject.Object.IsArrangeValid.ShouldBeFalse();

        private It should_invalidate_measure = () => Subject.Object.IsMeasureValid.ShouldBeFalse();
    }

    [Subject(typeof(UIElement), "Layout - Invalidate")]
    public class when_minimum_height_is_changed : a_Measured_and_Arranged_UIElement
    {
        private Because of = () => Subject.Object.MinHeight = 100;

        private It should_invalidate_arrange = () => Subject.Object.IsArrangeValid.ShouldBeFalse();

        private It should_invalidate_measure = () => Subject.Object.IsMeasureValid.ShouldBeFalse();
    }

    [Subject(typeof(UIElement), "Layout - Invalidate")]
    public class when_maximum_height_is_changed : a_Measured_and_Arranged_UIElement
    {
        private Because of = () => Subject.Object.MaxHeight = 100;

        private It should_invalidate_arrange = () => Subject.Object.IsArrangeValid.ShouldBeFalse();

        private It should_invalidate_measure = () => Subject.Object.IsMeasureValid.ShouldBeFalse();
    }

    [Subject(typeof(UIElement), "Layout - Invalidate")]
    public class when_width_is_changed : a_Measured_and_Arranged_UIElement
    {
        private Because of = () => Subject.Object.Width = 100;

        private It should_invalidate_arrange = () => Subject.Object.IsArrangeValid.ShouldBeFalse();

        private It should_invalidate_measure = () => Subject.Object.IsMeasureValid.ShouldBeFalse();
    }

    [Subject(typeof(UIElement), "Layout - Invalidate")]
    public class when_minimum_width_is_changed : a_Measured_and_Arranged_UIElement
    {
        private Because of = () => Subject.Object.MinWidth = 100;

        private It should_invalidate_arrange = () => Subject.Object.IsArrangeValid.ShouldBeFalse();

        private It should_invalidate_measure = () => Subject.Object.IsMeasureValid.ShouldBeFalse();
    }

    [Subject(typeof(UIElement), "Layout - Invalidate")]
    public class when_maximum_width_is_changed : a_Measured_and_Arranged_UIElement
    {
        private Because of = () => Subject.Object.MaxWidth = 100;

        private It should_invalidate_arrange = () => Subject.Object.IsArrangeValid.ShouldBeFalse();

        private It should_invalidate_measure = () => Subject.Object.IsMeasureValid.ShouldBeFalse();
    }

    [Subject(typeof(UIElement), "Layout - Invalidate")]
    public class when_margin_is_changed : a_Measured_and_Arranged_UIElement
    {
        private Because of = () => Subject.Object.Margin = new Thickness(10, 20, 30, 40);

        private It should_invalidate_arrange = () => Subject.Object.IsArrangeValid.ShouldBeFalse();

        private It should_invalidate_measure = () => Subject.Object.IsMeasureValid.ShouldBeFalse();
    }

    [Subject(typeof(UIElement), "Layout - Invalidate")]
    public class when_horizontal_alignment_is_changed : a_Measured_and_Arranged_UIElement
    {
        private Because of = () => Subject.Object.HorizontalAlignment = HorizontalAlignment.Left;

        private It should_invalidate_arrange = () => Subject.Object.IsArrangeValid.ShouldBeFalse();

        private It should_not_invalidate_measure = () => Subject.Object.IsMeasureValid.ShouldBeTrue();
    }

    [Subject(typeof(UIElement), "Layout - Invalidate")]
    public class when_vertical_alignment_is_changed : a_Measured_and_Arranged_UIElement
    {
        private Because of = () => Subject.Object.VerticalAlignment = VerticalAlignment.Bottom;

        private It should_invalidate_arrange = () => Subject.Object.IsArrangeValid.ShouldBeFalse();

        private It should_not_invalidate_measure = () => Subject.Object.IsMeasureValid.ShouldBeTrue();
    }

    [Subject(typeof(UIElement), "Layout - Invalidate")]
    public class when_data_context_is_changed : a_Measured_and_Arranged_UIElement
    {
        private Because of = () => Subject.Object.DataContext = new object();

        private It should_invalidate_arrange = () => Subject.Object.IsArrangeValid.ShouldBeFalse();

        private It should_invalidate_measure = () => Subject.Object.IsMeasureValid.ShouldBeFalse();
    }

    [Subject(typeof(UIElement), "Layout - Size Change")]
    public class when_the_available_size_changes : a_Measured_UIElement
    {
        private Because of = () => Subject.Object.Measure(new Size(200, 200));

        private It should_measure_again =
            () => Subject.Protected().Verify(MeasureOverride, Times.Exactly(2), ItExpr.IsAny<Size>());
    }

    [Subject(typeof(UIElement), "Layout - Size Change")]
    public class when_the_available_size_doesnt_change_enough : a_Measured_UIElement
    {
        private Because of = () => Subject.Object.Measure(new Size(100.000001f, 100.000001f));

        private It should_not_measure_again =
            () => Subject.Protected().Verify(MeasureOverride, Times.Once(), ItExpr.IsAny<Size>());
    }

    [Subject(typeof(UIElement), "Layout - Size Change")]
    public class when_the_final_size_changes : a_Measured_and_Arranged_UIElement
    {
        private Because of = () => Subject.Object.Arrange(new Rect(new Size(200, 200)));

        private It should_arrange_again =
            () => Subject.Protected().Verify(ArrangeOverride, Times.Exactly(2), ItExpr.IsAny<Size>());
    }

    [Subject(typeof(UIElement), "Layout - Size Change")]
    public class when_the_final_size_doesnt_change_enough : a_Measured_and_Arranged_UIElement
    {
        private Because of = () => Subject.Object.Arrange(new Rect(new Size(100.000001f, 100.000001f)));

        private It should_not_arrange_again =
            () => Subject.Protected().Verify(ArrangeOverride, Times.Once(), ItExpr.IsAny<Size>());
    }
}
