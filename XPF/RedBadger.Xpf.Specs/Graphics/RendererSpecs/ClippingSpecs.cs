#region License
/* The MIT License
 *
 * Copyright (c) 2011 Red Badger Consulting
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
*/
#endregion

//-------------------------------------------------------------------------------------------------
// <auto-generated> 
// Marked as auto-generated so StyleCop will ignore BDD style tests
// </auto-generated>
//-------------------------------------------------------------------------------------------------

#pragma warning disable 169
// ReSharper disable InconsistentNaming
// ReSharper disable UnusedMember.Global
// ReSharper disable UnusedMember.Local

namespace RedBadger.Xpf.Specs.Graphics.RendererSpecs
{
    using Machine.Specifications;

    using Moq;

    using RedBadger.Xpf.Adapters.Xna.Graphics;
    using RedBadger.Xpf.Controls;

    using It = Machine.Specifications.It;

    [Subject(typeof(Renderer), "Clipping")]
    public class when_a_child_should_be_clipped : a_Renderer
    {
        private static readonly Rect viewport = new Rect(10, 20, 200, 200);

        private static Mock<UIElement> child;

        private static Mock<RootElement> rootElement;

        private Establish context = () =>
            {
                rootElement = new Mock<RootElement>(viewport, Renderer) { CallBase = true };

                child = new Mock<UIElement> { CallBase = true };
                child.Object.Width = 300;
                child.Object.Height = 400;

                rootElement.Object.Content = child.Object;
            };

        private Because of = () => rootElement.Object.Update();

        private It should_create_a_clipping_rect_for_the_child =
            () => ((DrawingContext)Renderer.GetDrawingContext(child.Object)).AbsoluteClippingRect.ShouldEqual(viewport);

        private It should_not_create_a_clipping_rect_for_the_parent =
            () =>
            ((DrawingContext)Renderer.GetDrawingContext(rootElement.Object)).AbsoluteClippingRect.ShouldEqual(
                Rect.Empty);
    }

    [Subject(typeof(Renderer), "Clipping")]
    public class when_a_child_should_not_be_clipped : a_Renderer
    {
        private static readonly Rect viewport = new Rect(10, 20, 200, 200);

        private static Mock<UIElement> child;

        private static Mock<RootElement> rootElement;

        private Establish context = () =>
            {
                rootElement = new Mock<RootElement>(viewport, Renderer) { CallBase = true };

                child = new Mock<UIElement> { CallBase = true };
                child.Object.Width = 199.99;
                child.Object.Height = 199.99;

                rootElement.Object.Content = child.Object;
            };

        private Because of = () => rootElement.Object.Update();

        private It should_create_a_clipping_rect_for_the_child =
            () =>
            ((DrawingContext)Renderer.GetDrawingContext(child.Object)).AbsoluteClippingRect.ShouldEqual(Rect.Empty);

        private It should_create_a_clipping_rect_for_the_parent =
            () =>
            ((DrawingContext)Renderer.GetDrawingContext(rootElement.Object)).AbsoluteClippingRect.ShouldEqual(
                Rect.Empty);
    }

    [Subject(typeof(Renderer), "Clipping")]
    public class when_there_is_a_hierarchy_of_elements_some_of_which_need_clipping : a_Renderer
    {
        private static readonly Rect viewport = new Rect(10, 20, 500, 500);

        private static StackPanel child_10_StackPanel;

        private static Border child_20_Border;

        private static Border child_21_Border;

        private static StackPanel child_30_StackPanel;

        private static Border child_40_Border;

        private static Border child_41_Border;

        private static Border child_50_Border;

        private static double horizontalOffset;

        private static RootElement rootElement;

        private static double verticalOffset;

        private Establish context = () =>
            {
                rootElement = new RootElement(viewport, Renderer);

                child_10_StackPanel = new StackPanel();

                child_20_Border = new Border { Width = 200, Height = 300 };
                child_21_Border = new Border { Width = 100, Height = 100 };

                child_30_StackPanel = new StackPanel { Width = 300, Height = 400 };

                child_40_Border = new Border { Width = 400, Height = 500 };
                child_41_Border = new Border { Width = 600, Height = 700 };

                child_50_Border = new Border { Width = 500, Height = 600 };

                rootElement.Content = child_10_StackPanel;

                child_10_StackPanel.Children.Add(child_20_Border);
                child_10_StackPanel.Children.Add(child_21_Border);

                child_20_Border.Child = child_30_StackPanel;

                child_30_StackPanel.Children.Add(child_40_Border);
                child_30_StackPanel.Children.Add(child_41_Border);

                child_40_Border.Child = child_50_Border;

                horizontalOffset = (viewport.Width - child_20_Border.Width) / 2 + viewport.X;
                verticalOffset = viewport.Y;
            };

        private Because of = () => rootElement.Update();

        private It should_00_root_element_should_not_have_a_clipping_rect =
            () => rootElement.ClippingRect.ShouldEqual(Rect.Empty);

        private It should_00_root_element_should_not_have_an_absolute_clipping_rect =
            () => ((DrawingContext)Renderer.GetDrawingContext(rootElement)).AbsoluteClippingRect.ShouldEqual(Rect.Empty);

        private It should_child_10_StackPanel_should_not_have_a_clipping_rect =
            () => child_10_StackPanel.ClippingRect.ShouldEqual(Rect.Empty);

        private It should_child_10_StackPanel_should_not_have_an_absolute_clipping_rect =
            () =>
            ((DrawingContext)Renderer.GetDrawingContext(child_10_StackPanel)).AbsoluteClippingRect.ShouldEqual(
                Rect.Empty);

        private It should_child_20_Border_should_not_have_a_clipping_rect =
            () => child_20_Border.ClippingRect.ShouldEqual(Rect.Empty);

        private It should_child_20_Border_should_not_have_an_absolute_clipping_rect =
            () =>
            ((DrawingContext)Renderer.GetDrawingContext(child_20_Border)).AbsoluteClippingRect.ShouldEqual(Rect.Empty);

        private It should_child_21_Border_should_not_have_a_clipping_rect =
            () => child_21_Border.ClippingRect.ShouldEqual(Rect.Empty);

        private It should_child_21_Border_should_not_have_an_absolute_clipping_rect =
            () =>
            ((DrawingContext)Renderer.GetDrawingContext(child_21_Border)).AbsoluteClippingRect.ShouldEqual(Rect.Empty);

        private It should_child_30_StackPanel_should_have_a_clipping_rect =
            () =>
            child_30_StackPanel.ClippingRect.ShouldEqual(new Rect(0, 0, child_20_Border.Width, child_20_Border.Height));

        private It should_child_30_StackPanel_should_have_an_absolute_clipping_rect =
            () =>
            ((DrawingContext)Renderer.GetDrawingContext(child_30_StackPanel)).AbsoluteClippingRect.ShouldEqual(
                new Rect(horizontalOffset, verticalOffset, child_20_Border.Width, child_20_Border.Height));

        private It should_child_40_Border_should_have_a_clipping_rect =
            () =>
            child_40_Border.ClippingRect.ShouldEqual(new Rect(0, 0, child_30_StackPanel.Width, child_40_Border.Height));

        private It should_child_40_Border_should_have_an_absolute_clipping_rect =
            () =>
            ((DrawingContext)Renderer.GetDrawingContext(child_40_Border)).AbsoluteClippingRect.ShouldEqual(
                new Rect(horizontalOffset, verticalOffset, child_20_Border.Width, child_20_Border.Height));

        private It should_child_41_Border_should_have_a_clipping_rect =
            () =>
            child_41_Border.ClippingRect.ShouldEqual(new Rect(0, 0, child_30_StackPanel.Width, child_41_Border.Height));

        private It should_child_41_Border_should_have_an_absolute_clipping_rect =
            () =>
            ((DrawingContext)Renderer.GetDrawingContext(child_41_Border)).AbsoluteClippingRect.ShouldEqual(
                new Rect(horizontalOffset, verticalOffset, child_20_Border.Width, child_20_Border.Height));

        private It should_child_50_Border_should_have_a_clipping_rect =
            () =>
            child_50_Border.ClippingRect.ShouldEqual(new Rect(0, 0, child_40_Border.Width, child_40_Border.Height));

        private It should_child_50_Border_should_have_an_absolute_clipping_rect =
            () =>
            ((DrawingContext)Renderer.GetDrawingContext(child_50_Border)).AbsoluteClippingRect.ShouldEqual(
                new Rect(horizontalOffset, verticalOffset, child_20_Border.Width, child_20_Border.Height));
    }
}
