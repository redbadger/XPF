#region License
/* The MIT License
 *
 * Copyright (c) 2011 Red Badger Consulting
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
*/
#endregion

//-------------------------------------------------------------------------------------------------
// <auto-generated> 
// Marked as auto-generated so StyleCop will ignore BDD style tests
// </auto-generated>
//-------------------------------------------------------------------------------------------------
#pragma warning disable 169
// ReSharper disable InconsistentNaming
// ReSharper disable UnusedMember.Global
// ReSharper disable UnusedMember.Local

namespace RedBadger.Xpf.Specs
{
    using System;
    using System.Reflection;

    using Machine.Specifications;

    using Rhino.Mocks;

    public abstract class a_UIElement
    {
        protected static UIElement uiElement;

        private Establish context = () => uiElement = MockRepository.GenerateStub<UIElement>();
    }

    [Subject(typeof(UIElement), "Measuring")]
    public class when_the_supplied_available_size_Width_is_not_a_number : a_UIElement
    {
        private static Exception exception;

        private Because of = () => exception = Catch.Exception(() => uiElement.Measure(new Size(double.NaN, 0)));

        private It should_throw_a_Exception = () => exception.ShouldBeOfType<InvalidOperationException>();
    }

    [Subject(typeof(UIElement), "Measuring")]
    public class when_the_supplied_available_size_Height_is_not_a_number : a_UIElement
    {
        private static Exception exception;

        private Because of = () => exception = Catch.Exception(() => uiElement.Measure(new Size(0, double.NaN)));

        private It should_throw_a_Exception = () => exception.ShouldBeOfType<InvalidOperationException>();
    }

    [Subject(typeof(UIElement), "Measure")]
    public class when_measuring : a_UIElement
    {
        private static readonly Size availableSize = new Size(10, 10);

        private static readonly Size expectedDesiredSize = new Size(5, 5);

        private Establish context =
            () => uiElement.Expect(element => element.MeasureOverride(availableSize)).Return(new Size(5, 5));

        private Because of = () => uiElement.Measure(availableSize);

        private It should_be_marked_as_having_a_valid_Measure = () => uiElement.IsMeasureValid.ShouldBeTrue();

        private It should_have_a_desired_size_set = () => uiElement.DesiredSize.ShouldEqual(expectedDesiredSize);

        private It should_invalidate_arrange = () => uiElement.IsArrangeValid.ShouldBeFalse();
    }

    [Subject(typeof(UIElement), "Measure")]
    public class when_an_implementing_control_returns_a_size_greater_than_the_available_size : a_UIElement
    {
        private static readonly Size availableSize = new Size(10, 10);

        private Establish context =
            () => uiElement.Expect(element => element.MeasureOverride(availableSize)).Return(new Size(95, 100));

        private Because of = () => uiElement.Measure(availableSize);

        private It should_reduce_the_size_returned_to_keep_it_within_the_available_size_passed_to_Measure =
            () => uiElement.DesiredSize.ShouldEqual(availableSize);
    }

    [Subject(typeof(UIElement), "Measure")]
    public class when_the_implementing_controls_requested_size_combined_with_the_margin_exceeds_the_available_size :
        a_UIElement
    {
        private static readonly Size availableSize = new Size(10, 10);

        private Establish context = () =>
            {
                uiElement.Margin = new Thickness(10, 20, 30, 40);
                uiElement.Expect(element => element.MeasureOverride(availableSize)).IgnoreArguments().Return(
                    new Size(5, 5));
            };

        private Because of = () => uiElement.Measure(availableSize);

        private It should_reduce_the_size_returned_to_keep_it_within_the_available_size_passed_to_Measure =
            () => uiElement.DesiredSize.ShouldEqual(availableSize);
    }

    [Subject(typeof(UIElement), "Measure")]
    public class when_an_implementing_control_returns_a_width_of_positive_infinity : a_UIElement
    {
        private static readonly Size availableSize = new Size(double.PositiveInfinity, double.PositiveInfinity);

        private static Exception exception;

        private Establish context =
            () =>
            uiElement.Expect(element => element.MeasureOverride(availableSize)).Return(
                new Size(double.PositiveInfinity, 0));

        private Because of = () => exception = Catch.Exception(() => uiElement.Measure(availableSize));

        private It should_throw_an_exception = () => exception.ShouldBeOfType<InvalidOperationException>();
    }

    [Subject(typeof(UIElement), "Measure")]
    public class when_an_implementing_control_returns_a_height_of_positive_infinity : a_UIElement
    {
        private static readonly Size availableSize = new Size(double.PositiveInfinity, double.PositiveInfinity);

        private static Exception exception;

        private Establish context =
            () =>
            uiElement.Expect(element => element.MeasureOverride(availableSize)).Return(
                new Size(0, double.PositiveInfinity));

        private Because of = () => exception = Catch.Exception(() => uiElement.Measure(availableSize));

        private It should_throw_an_exception = () => exception.ShouldBeOfType<InvalidOperationException>();
    }

    [Subject(typeof(UIElement), "Measure")]
    public class when_an_implementing_control_returns_a_width_that_is_not_a_number : a_UIElement
    {
        private static readonly Size availableSize = new Size(double.PositiveInfinity, double.PositiveInfinity);

        private static Exception exception;

        private Establish context =
            () => uiElement.Expect(element => element.MeasureOverride(availableSize)).Return(new Size(double.NaN, 0));

        private Because of = () => exception = Catch.Exception(() => uiElement.Measure(availableSize));

        private It should_throw_an_exception = () => exception.ShouldBeOfType<InvalidOperationException>();
    }

    [Subject(typeof(UIElement), "Measure")]
    public class when_an_implementing_control_returns_a_height_that_is_not_a_number : a_UIElement
    {
        private static readonly Size availableSize = new Size(double.PositiveInfinity, double.PositiveInfinity);

        private static Exception exception;

        private Establish context =
            () => uiElement.Expect(element => element.MeasureOverride(availableSize)).Return(new Size(0, double.NaN));

        private Because of = () => exception = Catch.Exception(() => uiElement.Measure(availableSize));

        private It should_throw_an_exception = () => exception.ShouldBeOfType<InvalidOperationException>();
    }

    [Subject(typeof(UIElement), "Measure")]
    public class when_an_implementing_control_is_asked_to_measure_itself : a_UIElement
    {
        private static readonly Size availableSize = new Size(400, 300);

        private static readonly Thickness margin = new Thickness(10, 20, 30, 40);

        private Establish context = () => uiElement.Margin = margin;

        private Because of = () => uiElement.Measure(availableSize);

        private It should_be_given_an_available_size_that_does_not_include_margins = () =>
            {
                var expectedAvailableSize = new Size(
                    availableSize.Width - (margin.Left + margin.Right), 
                    availableSize.Height - (margin.Top + margin.Bottom));

                uiElement.AssertWasCalled(element => element.MeasureOverride(expectedAvailableSize));
            };
    }

    internal static class UIElementMockingExtensions
    {
        public static Size MeasureOverride(this UIElement element, Size availableSize)
        {
            object result =
                typeof(UIElement).GetMethod(
                    "MeasureOverride", 
                    BindingFlags.Instance | BindingFlags.NonPublic, 
                    null, 
                    new[] { typeof(Size) }, 
                    null).Invoke(element, new object[] { availableSize });

            return (Size)result;
        }
    }
}
