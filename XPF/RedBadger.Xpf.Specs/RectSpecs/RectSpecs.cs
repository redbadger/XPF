#region License
/* The MIT License
 *
 * Copyright (c) 2011 Red Badger Consulting
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
*/
#endregion

//-------------------------------------------------------------------------------------------------
// <auto-generated> 
// Marked as auto-generated so StyleCop will ignore BDD style tests
// </auto-generated>
//-------------------------------------------------------------------------------------------------
#pragma warning disable 169
// ReSharper disable InconsistentNaming
// ReSharper disable UnusedMember.Global
// ReSharper disable UnusedMember.Local

namespace RedBadger.Xpf.Specs.RectSpecs
{
    using System;

    using Machine.Specifications;

    using RedBadger.Xpf.Internal;

    [Subject(typeof(Rect))]
    public class when_constructed
    {
        private static Rect subject;

        private Establish context = () => subject = new Rect();

        private It should_have_a_position_at_zero_zero = () => subject.Location.ShouldEqual(new Point(0, 0));

        private It should_have_a_size_of_zero_zero = () => subject.Size.ShouldEqual(new Size(0, 0));

        private It should_not_be_equal_to_an_empty_rect = () => subject.ShouldNotEqual(Rect.Empty);

        private It should_not_say_it_is_empty = () => subject.IsEmpty.ShouldBeFalse();
    }

    [Subject(typeof(Rect))]
    public class when_constructed_with_an_X_a_Y_a_Width_and_a_Height
    {
        private const double Height = 10;

        private const double Width = 20;

        private const double X = 5;

        private const double Y = 15;

        private static Rect subject;

        private Establish context = () => subject = new Rect(X, Y, Width, Height);

        private It should_1_have_a_correct_left_side = () => subject.Left.ShouldEqual(5);

        private It should_2_have_a_correct_top_side = () => subject.Top.ShouldEqual(15);

        private It should_3_have_a_correct_right_side = () => subject.Right.ShouldEqual(25);

        private It should_4_have_a_correct_bottom_side = () => subject.Bottom.ShouldEqual(25);

        private It should_have_the_expected_location = () => subject.Location.ShouldEqual(new Point(X, Y));

        private It should_have_the_expected_size = () => subject.Size.ShouldEqual(new Size(Width, Height));
    }

    [Subject(typeof(Rect))]
    public class when_constructed_with_a_size
    {
        private static readonly Size size = new Size(10, 20);

        private static Rect subject;

        private Because of = () => subject = new Rect(size);

        private It should_have_a_position_at_zero_zero = () => subject.Location.ShouldEqual(new Point(0, 0));

        private It should_have_a_size_equal_to_the_specified_size = () => subject.Size.ShouldEqual(size);
    }

    [Subject(typeof(Rect))]
    public class when_constructed_with_a_position_and_a_size
    {
        private static readonly Point location = new Point(10, 20);

        private static readonly Size size = new Size(10, 20);

        private static Rect subject;

        private Because of = () => subject = new Rect(location, size);

        private It should_have_a_location_equal_to_the_specified_location = () => subject.Location.ShouldEqual(location);

        private It should_have_a_size_equal_to_the_specified_size = () => subject.Size.ShouldEqual(size);
    }

    [Subject(typeof(Rect))]
    public class when_a_rect_is_constructed_from_two_points
    {
        private static readonly Point point1 = new Point(10, 20);

        private static readonly Point point2 = new Point(30, 40);

        private static Rect subject;

        private Because of = () => subject = new Rect(point1, point2);

        private It should_contain_point_one = () => subject.Contains(point1).ShouldBeTrue();

        private It should_contain_point_two = () => subject.Contains(point2).ShouldBeTrue();

        private It should_encompass_the_two_points = () => subject.ShouldEqual(new Rect(10, 20, 20, 20));
    }

    [Subject(typeof(Rect))]
    public class when_two_rects_are_equal
    {
        private static Rect rect;

        private static bool result;

        private static Rect subject;

        private Establish context = () =>
            {
                subject = new Rect(10, 20, 30, 40);
                rect = new Rect(10, 20, 30, 40);
            };

        private Because of = () => result = subject == rect;

        private It should_show_them_as_equal = () => result.ShouldBeTrue();
    }

    [Subject(typeof(Rect))]
    public class when_two_rects_are_not_equal_in_the_x
    {
        private static Rect rect;

        private static bool result;

        private static Rect subject;

        private Establish context = () =>
            {
                subject = new Rect(10, 20, 30, 40);
                rect = new Rect(11, 20, 30, 40);
            };

        private Because of = () => result = subject == rect;

        private It should_show_them_as_not_equal = () => result.ShouldBeFalse();
    }

    [Subject(typeof(Rect))]
    public class when_two_rects_are_not_equal_in_the_y
    {
        private static Rect rect;

        private static bool result;

        private static Rect subject;

        private Establish context = () =>
            {
                subject = new Rect(10, 20, 30, 40);
                rect = new Rect(10, 21, 30, 40);
            };

        private Because of = () => result = rect == subject;

        private It should_show_them_as_not_equal = () => result.ShouldBeFalse();
    }

    [Subject(typeof(Rect))]
    public class when_two_rects_are_not_equal_in_the_width
    {
        private static Rect rect;

        private static bool result;

        private static Rect subject;

        private Establish context = () =>
            {
                subject = new Rect(10, 20, 30, 40);
                rect = new Rect(10, 20, 31, 40);
            };

        private Because of = () => result = rect == subject;

        private It should_show_them_as_not_equal = () => result.ShouldBeFalse();
    }

    [Subject(typeof(Rect))]
    public class when_two_rects_are_not_equal_in_the_height
    {
        private static Rect rect;

        private static bool result;

        private static Rect subject;

        private Establish context = () =>
            {
                subject = new Rect(10, 20, 30, 40);
                rect = new Rect(10, 20, 30, 41);
            };

        private Because of = () => result = rect == subject;

        private It should_show_them_as_not_equal = () => result.ShouldBeFalse();
    }

    [Subject(typeof(Rect))]
    public class when_a_Rect_is_displaced_by_a_vector
    {
        private static Rect subject;

        private static Vector vector;

        private Establish context = () =>
            {
                subject = new Rect(10, 20, 30, 40);
                vector = new Vector(1, 2);
            };

        private Because of = () => subject.Displace(vector);

        private It should_displace_the_rect_by_the_vector = () => subject.ShouldEqual(new Rect(11, 22, 30, 40));
    }

    [Subject(typeof(Rect))]
    public class when_an_empty_Rect_is_displaced_by_a_vector
    {
        private static Rect subject;

        private static Vector vector;

        private Establish context = () =>
            {
                subject = Rect.Empty;
                vector = new Vector(1, 2);
            };

        private Because of = () => subject.Displace(vector);

        private It should_not_displace_the_rect = () => subject.IsEmpty.ShouldBeTrue();
    }

    [Subject(typeof(Rect))]
    public class when_an_empty_rect_is_requested
    {
        private static Rect subject;

        private Because of = () => subject = Rect.Empty;

        private It should_have_a_height_of_negative_infinity = () => subject.Height.ShouldEqual(Double.NegativeInfinity);

        private It should_have_a_width_of_negative_infinity = () => subject.Width.ShouldEqual(Double.NegativeInfinity);

        private It should_have_an_x_location_of_infinity = () => subject.X.ShouldEqual(Double.PositiveInfinity);

        private It should_have_an_y_location_of_infinity = () => subject.Y.ShouldEqual(Double.PositiveInfinity);
    }

    [Subject(typeof(Rect))]
    public class when_an_empty_rect_is_asked_if_it_is_empty
    {
        private static Rect subject;

        private Because of = () => subject = Rect.Empty;

        private It should_return_true = () => subject.IsEmpty.ShouldBeTrue();
    }

    [Subject(typeof(Rect))]
    public class when_a_rect_is_asked_if_it_contains_a_point_that_is_inside_its_boundary
    {
        private static bool result;

        private static Rect subject;

        private Establish context = () => subject = new Rect(0, 0, 100, 100);

        private Because of = () => result = subject.Contains(new Point(50, 50));

        private It should_return_true = () => result.ShouldBeTrue();
    }

    [Subject(typeof(Rect))]
    public class when_a_rect_is_asked_if_it_contains_a_point_that_is_outside_its_boundary
    {
        private static bool result;

        private static Rect subject;

        private Establish context = () => subject = new Rect(0, 0, 100, 100);

        private Because of = () => result = subject.Contains(new Point(150, 50));

        private It should_return_true = () => result.ShouldBeFalse();
    }

    [Subject(typeof(Rect))]
    public class when_a_rect_is_unioned_with_another_rect
    {
        private static Rect anotherRect;

        private static Rect subject;

        private Establish context = () =>
            {
                subject = new Rect(10, 20, 30, 40);
                anotherRect = new Rect(20, 30, 40, 50);
            };

        private Because of = () => subject.Union(anotherRect);

        private It should_encompass_both_rects = () => subject.ShouldEqual(new Rect(10, 20, 50, 60));
    }

    [Subject(typeof(Rect))]
    public class when_a_rect_is_unioned_with_a_point
    {
        private static Point point;

        private static Rect subject;

        private Establish context = () =>
            {
                subject = new Rect(10, 20, 30, 40);
                point = new Point(80, 100);
            };

        private Because of = () => subject.Union(point);

        private It should_encompass_both_rects = () => subject.ShouldEqual(new Rect(10, 20, 70, 80));
    }

    [Subject(typeof(Rect))]
    public class when_a_rect_is_asked_if_it_intersects_with_another_rect_that_it_instersects_with
    {
        private static Rect anotherRect;

        private static bool result;

        private static Rect subject;

        private Establish context = () =>
            {
                subject = new Rect(10, 20, 30, 40);
                anotherRect = new Rect(30, 40, 50, 60);
            };

        private Because of = () => result = subject.IntersectsWith(anotherRect);

        private It should_return_true = () => result.ShouldBeTrue();
    }

    [Subject(typeof(Rect))]
    public class when_a_rect_is_asked_if_it_intersects_with_another_rect_that_it_doesnt_instersect_with
    {
        private static Rect anotherRect;

        private static bool result;

        private static Rect subject;

        private Establish context = () =>
            {
                subject = new Rect(10, 20, 30, 40);
                anotherRect = new Rect(130, 140, 150, 160);
            };

        private Because of = () => result = subject.IntersectsWith(anotherRect);

        private It should_return_true = () => result.ShouldBeFalse();
    }

    [Subject(typeof(Rect))]
    public class when_a_rect_is_intersected_with_another_rect
    {
        private static Rect anotherRect;

        private static Rect subject;

        private Establish context = () =>
            {
                subject = new Rect(10, 20, 30, 40);
                anotherRect = new Rect(30, 40, 50, 60);
            };

        private Because of = () => subject.Intersect(anotherRect);

        private It should_return_true = () => subject.ShouldEqual(new Rect(30, 40, 10, 20));
    }

    [Subject(typeof(Rect))]
    public class when_a_rect_is_deflated_by_a_thickness
    {
        private static readonly Thickness thickness = new Thickness(1, 2, 3, 4);

        private static Rect result;

        private static Rect subject;

        private Establish context = () => subject = new Rect(10, 20, 30, 40);

        private Because of = () => result = subject.Deflate(thickness);

        private It should_reduce_the_rect_by_the_correct_amount = () => result.ShouldEqual(new Rect(11, 22, 26, 34));
    }
}
