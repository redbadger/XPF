#region License
/* The MIT License
 *
 * Copyright (c) 2011 Red Badger Consulting
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
*/
#endregion

//-------------------------------------------------------------------------------------------------
// <auto-generated> 
// Marked as auto-generated so StyleCop will ignore BDD style tests
// </auto-generated>
//-------------------------------------------------------------------------------------------------

#pragma warning disable 169
// ReSharper disable InconsistentNaming
// ReSharper disable UnusedMember.Global
// ReSharper disable UnusedMember.Local

namespace RedBadger.Xpf.Specs.VirtualizingElementCollectionSpecs
{
    using System.Linq;

    using Machine.Specifications;

    using Moq;

    using It = Machine.Specifications.It;

    public abstract class a_VirtualElementCollection
    {
        protected static UIElement Owner = new Mock<UIElement> { CallBase = true }.Object;

        protected static VirtualizingElementCollection Subject;

        private Establish context = () => Subject = new VirtualizingElementCollection(Owner);
    }

    [Subject(typeof(VirtualizingElementCollection), "Add")]
    public class when_inserting_an_element : a_VirtualElementCollection
    {
        private Because of = () => Subject.Insert(0, new object(), _ => new Mock<UIElement> { CallBase = true }.Object);

        private It should_insert_an_element_of_the_right_type = () => Subject[0].ShouldBeOfType<UIElement>();
    }

    [Subject(typeof(VirtualizingElementCollection), "Insert")]
    public class when_adding_an_element : a_VirtualElementCollection
    {
        private Because of = () => Subject.Add(null, _ => new Mock<UIElement>().Object);

        private It should_add_an_element_of_the_right_type = () => Subject[0].ShouldBeOfType<UIElement>();
    }

    [Subject(typeof(VirtualizingElementCollection), "Remove")]
    public class when_removing_an_element : a_VirtualElementCollection
    {
        private Establish context = () => Subject.Add(null, _ => new Mock<IElement>().Object);

        private Because of = () => Subject.RemoveAt(0);

        private It should_remove_the_element = () => Subject.Count.ShouldEqual(0);
    }

    [Subject(typeof(VirtualizingElementCollection), "Move")]
    public class when_moving_an_element : a_VirtualElementCollection
    {
        private static IElement element1;

        private static IElement element2;

        private Establish context = () =>
            {
                element1 = new Mock<IElement>().Object;
                Subject.Add(null, _ => element1);
                element2 = new Mock<IElement>().Object;
                Subject.Add(null, _ => element2);
            };

        private Because of = () => Subject.Move(0, 1);

        private It should_move_the_element = () => Subject[1].ShouldBeTheSameAs(element1);

        private It should_shift_the_existing_element = () => Subject[0].ShouldBeTheSameAs(element2);
    }

    [Subject(typeof(VirtualizingElementCollection), "Realization")]
    public class when_realizing_an_element : a_VirtualElementCollection
    {
        private static readonly object item = new object();

        private static IElement element;

        private Establish context = () =>
            {
                Subject.Add(item, _ => new Mock<UIElement> { CallBase = true }.Object);
                Owner.Measure(new Size());
            };

        private Because of = () =>
            {
                using (VirtualizingElementCollection.Cursor cursor = Subject.GetCursor(0))
                {
                    element = cursor.First();
                }
            };

        private It should_have_a_realized_count_of_1 = () => Subject.RealizedElements.Count().ShouldEqual(1);

        private It should_invalidate_its_owners_measure = () => Owner.IsMeasureValid.ShouldBeFalse();

        private It should_realize_the_element = () => element.ShouldNotBeNull();

        private It should_set_the_data_context_of_the_element = () => element.DataContext.ShouldBeTheSameAs(item);

        private It should_set_the_elements_visual_parent = () => element.VisualParent.ShouldBeTheSameAs(Owner);
    }

    [Subject(typeof(VirtualizingElementCollection), "Realization")]
    public class when_realizing_an_already_realized_element : a_VirtualElementCollection
    {
        private static object originalContext;

        private static IElement realized1;

        private static IElement realized2;

        private Establish context = () =>
            {
                Subject.Add(new object(), _ => new Mock<UIElement> { CallBase = true }.Object);
                using (VirtualizingElementCollection.Cursor cursor = Subject.GetCursor(0))
                {
                    realized1 = cursor.First();
                }

                originalContext = realized1.DataContext;
                Owner.Measure(new Size());
            };

        private Because of = () =>
            {
                using (VirtualizingElementCollection.Cursor cursor = Subject.GetCursor(0))
                {
                    realized2 = cursor.First();
                }
            };

        private It should_have_a_realized_count_of_1 = () => Subject.RealizedElements.Count().ShouldEqual(1);

        private It should_not_change_the_data_context = () => realized2.DataContext.ShouldBeTheSameAs(originalContext);

        private It should_not_change_the_elements_visual_parent =
            () => realized2.VisualParent.ShouldBeTheSameAs(realized1.VisualParent);

        private It should_not_invalidate_its_owners_measure = () => Owner.IsMeasureValid.ShouldBeTrue();

        private It should_not_realize_the_element_again = () => realized2.ShouldBeTheSameAs(realized1);

        private It should_still_be_realized = () => Subject.IsReal(0).ShouldBeTrue();
    }

    [Subject(typeof(VirtualizingElementCollection), "Virtualization")]
    public class when_virtualizing_an_element : a_VirtualElementCollection
    {
        private static IElement element;

        private Establish context = () =>
            {
                Subject.Add(null, _ => new Mock<UIElement> { CallBase = true }.Object);
                Subject.Add(null, _ => new Mock<UIElement> { CallBase = true }.Object);
                using (VirtualizingElementCollection.Cursor cursor = Subject.GetCursor(0))
                {
                    element = cursor.First();
                }

                Owner.Measure(new Size());
            };

        private Because of = () =>
            {
                using (VirtualizingElementCollection.Cursor cursor = Subject.GetCursor(1))
                {
                    cursor.First();
                }
            };

        private It should_have_a_realized_count_of_1 = () => Subject.RealizedElements.Count().ShouldEqual(1);

        private It should_invalidate_its_owners_measure = () => Owner.IsMeasureValid.ShouldBeFalse();

        private It should_unset_the_elements_data_context = () => element.DataContext.ShouldBeNull();

        private It should_unset_the_elements_visual_parent = () => element.VisualParent.ShouldBeNull();

        private It should_virtualize_the_element = () => Subject.IsReal(0).ShouldBeFalse();
    }

    [Subject(typeof(VirtualizingElementCollection), "Virtualization")]
    public class when_asked_for_a_count_and_there_are_both_real_and_virtual_elements : a_VirtualElementCollection
    {
        private static int count;

        private Establish context = () =>
            {
                Subject.Add(null, _ => new Mock<IElement>().Object);
                Subject.Add(null, _ => new Mock<IElement>().Object);
                using (VirtualizingElementCollection.Cursor cursor = Subject.GetCursor(1))
                {
                    cursor.First();
                }
            };

        private Because of = () => count = Subject.Count;

        private It should_count_both_real_and_virtual_elements = () => count.ShouldEqual(2);

        private It should_have_a_realized_count_of_1 = () => Subject.RealizedElements.Count().ShouldEqual(1);
    }

    [Subject(typeof(VirtualizingElementCollection), "Virtualization")]
    public class when_asked_for_a_virtual_element : a_VirtualElementCollection
    {
        private static IElement element;

        private Establish context = () => Subject.Add(null, _ => new Mock<IElement>().Object);

        private Because of = () => element = Subject[0];

        private It should_not_realize_the_element_in_the_collection = () => Subject.IsReal(0).ShouldBeFalse();

        private It should_return_a_realized_element = () => element.ShouldNotBeNull();
    }

    [Subject(typeof(VirtualizingElementCollection), "Virtualization")]
    public class when_clearing_the_collection : a_VirtualElementCollection
    {
        private Establish context = () => Subject.Add(null, _ => new Mock<IElement>().Object);

        private Because of = () => Subject.Clear();

        private It should_return_a_count_of_zero = () => Subject.Count.ShouldEqual(0);
    }

    [Subject(typeof(VirtualizingElementCollection), "Virtualization")]
    public class when_asked_if_it_contains_a_specific_element : a_VirtualElementCollection
    {
        private static bool doesContainElement;

        private static IElement element;

        private Establish context = () =>
            {
                element = new Mock<IElement>().Object;
                Subject.Add(null, _ => element);
            };

        private Because of = () => doesContainElement = Subject.Contains(element);

        private It should_always_return_false = () => doesContainElement.ShouldBeFalse();
    }

    [Subject(typeof(VirtualizingElementCollection), "Virtualization")]
    public class when_a_collection_that_contains_real_and_virtual_elements_is_enumerated : a_VirtualElementCollection
    {
        private static bool areAnyNull;

        private Establish context = () =>
            {
                Subject.Add(null, _ => new Mock<IElement>().Object);
                Subject.Add(null, _ => new Mock<IElement>().Object);
                using (VirtualizingElementCollection.Cursor cursor = Subject.GetCursor(1))
                {
                    cursor.First();
                }
            };

        private Because of = () => areAnyNull = Subject.Any(element => element == null);

        private It should_not_realize_virtual_elements = () => Subject.IsReal(0).ShouldBeFalse();

        private It should_return_elements_that_are_not_null = () => areAnyNull.ShouldBeFalse();
    }
}
