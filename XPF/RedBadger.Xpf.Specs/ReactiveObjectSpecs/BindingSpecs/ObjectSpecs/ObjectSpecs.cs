#region License
/* The MIT License
 *
 * Copyright (c) 2011 Red Badger Consulting
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
*/
#endregion

//-------------------------------------------------------------------------------------------------
// <auto-generated> 
// Marked as auto-generated so StyleCop will ignore BDD style tests
// </auto-generated>
//-------------------------------------------------------------------------------------------------

#pragma warning disable 169
// ReSharper disable InconsistentNaming
// ReSharper disable UnusedMember.Global
// ReSharper disable UnusedMember.Local

namespace RedBadger.Xpf.Specs.ReactiveObjectSpecs.BindingSpecs.ObjectSpecs
{
    using System;

    using Machine.Specifications;

    using Moq;

    using RedBadger.Xpf.Controls;
    using RedBadger.Xpf.Data;
    using RedBadger.Xpf.Graphics;
    using RedBadger.Xpf.Media;

    using It = Machine.Specifications.It;

    public class TestBindingObject
    {
        public Brush Brush { get; set; }

        public string BrushAsString { get; set; }

        public SolidColorBrush SolidColorBrush { get; set; }
    }

    public class TestBindingReactiveObject : ReactiveObject
    {
        public static readonly ReactiveProperty<SolidColorBrush> SolidColorBrushProperty =
            ReactiveProperty<SolidColorBrush>.Register("SolidColorBrush", typeof(TestBindingReactiveObject));

        public SolidColorBrush SolidColorBrush
        {
            get
            {
                return this.GetValue(SolidColorBrushProperty);
            }

            set
            {
                this.SetValue(SolidColorBrushProperty, value);
            }
        }
    }

    [Subject(typeof(ReactiveObject), "One Way")]
    public class when_there_is_a_one_way_binding_to_the_data_context_which_is_an_object
    {
        private const double ExpectedWidth = 10d;

        private static Border target;

        private Establish context = () => target = new Border { DataContext = ExpectedWidth };

        private Because of = () =>
            {
                IObservable<double> fromSource = BindingFactory.CreateOneWay<double>();
                target.Bind(UIElement.WidthProperty, fromSource);
                target.Measure(Size.Empty);
            };

        private It should_update_the_target = () => target.Width.ShouldEqual(ExpectedWidth);
    }

    [Subject(typeof(ReactiveObject), "One Way")]
    public class when_there_is_a_one_way_binding_to_the_data_context_which_is_an_object_and_type_conversion_is_required
    {
        private const string ExpectedWidth = "10.0";

        private static Border target;

        private Establish context = () => target = new Border { DataContext = ExpectedWidth };

        private Because of = () =>
            {
                IObservable<double> fromSource = BindingFactory.CreateOneWay<double>();
                target.Bind(UIElement.WidthProperty, fromSource);
                target.Measure(Size.Empty);
            };

        private It should_update_the_target = () => target.Width.ShouldEqual(Convert.ToDouble(ExpectedWidth));
    }

    [Subject(typeof(ReactiveObject), "One Way")]
    public class when_there_is_a_one_way_binding_to_a_specified_source_which_is_an_object
    {
        private const double ExpectedWidth = 10d;

        private static Border target;

        private Establish context = () => target = new Border();

        private Because of = () =>
            {
                IObservable<double> fromSource = BindingFactory.CreateOneWay(ExpectedWidth);
                target.Bind(UIElement.WidthProperty, fromSource);
            };

        private It should_update_the_target = () => target.Width.ShouldEqual(ExpectedWidth);
    }

    [Subject(typeof(ReactiveObject), "One Way")]
    public class when_there_is_a_one_way_binding_to_a_specified_source_which_is_an_object_and_type_conversion_is_required
    {
        private const string ExpectedWidth = "10.0";

        private static Border target;

        private Establish context = () => target = new Border();

        private Because of = () =>
            {
                IObservable<double> fromSource = BindingFactory.CreateOneWay<string, double>(ExpectedWidth);
                target.Bind(UIElement.WidthProperty, fromSource);
            };

        private It should_update_the_target = () => target.Width.ShouldEqual(Convert.ToDouble(ExpectedWidth));
    }

    [Subject(typeof(ReactiveObject), "One Way")]
    public class when_there_is_a_one_way_binding_to_a_property_on_the_data_context
    {
        private static TestBindingObject bindingObject;

        private static Border target;

        private Establish context = () =>
            {
                bindingObject = new TestBindingObject { Brush = new SolidColorBrush(Colors.Blue) };
                target = new Border { DataContext = bindingObject };
            };

        private Because of = () =>
            {
                IObservable<Brush> fromSource = BindingFactory.CreateOneWay<TestBindingObject, Brush>(o => o.Brush);
                target.Bind(Border.BorderBrushProperty, fromSource);
                target.Measure(Size.Empty);
            };

        private It should_update_the_target = () => target.BorderBrush.ShouldEqual(bindingObject.Brush);
    }

    [Subject(typeof(ReactiveObject), "One Way")]
    public class when_there_is_a_one_way_binding_to_a_property_on_the_data_context_and_type_conversion_is_required
    {
        private static TestBindingObject bindingObject;

        private static TextBlock target;

        private Establish context = () =>
            {
                bindingObject = new TestBindingObject { Brush = new SolidColorBrush(Colors.Blue) };
                target = new TextBlock(new Mock<ISpriteFont>().Object) { DataContext = bindingObject };
            };

        private Because of = () =>
            {
                IObservable<string> fromSource =
                    BindingFactory.CreateOneWay<TestBindingObject, Brush, string>(o => o.Brush);
                target.Bind(TextBlock.TextProperty, fromSource);
                target.Measure(Size.Empty);
            };

        private It should_update_the_target = () => target.Text.ShouldEqual(bindingObject.Brush.ToString());
    }

    [Subject(typeof(ReactiveObject), "One Way")]
    public class when_there_is_a_one_way_binding_to_a_property_on_a_specified_source
    {
        private static TestBindingObject bindingObject;

        private static Border target;

        private Establish context = () =>
            {
                bindingObject = new TestBindingObject { Brush = new SolidColorBrush(Colors.Blue) };
                target = new Border();
            };

        private Because of = () =>
            {
                IObservable<Brush> fromSource = BindingFactory.CreateOneWay(bindingObject, o => o.Brush);
                target.Bind(Border.BorderBrushProperty, fromSource);
            };

        private It should_update_the_target = () => target.BorderBrush.ShouldEqual(bindingObject.Brush);
    }

    [Subject(typeof(ReactiveObject), "One Way")]
    public class when_there_is_a_one_way_binding_to_a_property_on_a_specified_source_and_type_conversion_is_required
    {
        private static TestBindingObject bindingObject;

        private static TextBlock target;

        private Establish context = () =>
            {
                bindingObject = new TestBindingObject { Brush = new SolidColorBrush(Colors.Blue) };
                target = new TextBlock(new Mock<ISpriteFont>().Object);
            };

        private Because of = () =>
            {
                IObservable<string> fromSource =
                    BindingFactory.CreateOneWay<TestBindingObject, Brush, string>(bindingObject, o => o.Brush);
                target.Bind(TextBlock.TextProperty, fromSource);
            };

        private It should_update_the_target = () => target.Text.ShouldEqual(bindingObject.Brush.ToString());
    }

    [Subject(typeof(ReactiveObject), "One Way")]
    public class when_there_is_a_one_way_binding_and_the_source_type_is_more_derived
    {
        private static readonly SolidColorBrush expectedBrush = new SolidColorBrush(Colors.Brown);

        private static Border target;

        private Establish context = () => target = new Border();

        private Because of = () =>
            {
                IObservable<Brush> fromSource = BindingFactory.CreateOneWay(expectedBrush);
                target.Bind(Border.BorderBrushProperty, fromSource);
            };

        private It should_update_the_target = () => target.BorderBrush.ShouldEqual(expectedBrush);
    }

    [Subject(typeof(ReactiveObject), "One Way To Source")]
    public class when_there_is_a_one_way_to_source_binding_to_a_property_on_the_data_context
    {
        private static readonly Brush expectedBrush = new SolidColorBrush(Colors.Brown);

        private static readonly Brush expectedInitialBrush = new SolidColorBrush(Colors.Blue);

        private static Brush initialBrush;

        private static TestBindingObject source;

        private static Border target;

        private Establish context = () =>
            {
                source = new TestBindingObject();
                target = new Border { DataContext = source, BorderBrush = expectedInitialBrush };

                IObserver<Brush> toSource = BindingFactory.CreateOneWayToSource<TestBindingObject, Brush>(o => o.Brush);
                target.Bind(Border.BorderBrushProperty, toSource);
                target.Measure(Size.Empty);
            };

        private Because of = () =>
            {
                initialBrush = source.Brush;
                target.BorderBrush = expectedBrush;
            };

        private It should_update_the_source_with_the_initial_value =
            () => initialBrush.ShouldEqual(expectedInitialBrush);

        private It should_update_the_source_with_the_updated_value = () => source.Brush.ShouldEqual(expectedBrush);
    }

    [Subject(typeof(ReactiveObject), "One Way To Source")]
    public class
        when_there_is_a_one_way_to_source_binding_to_a_property_on_the_data_context_and_type_conversion_is_required
    {
        private static readonly Brush expectedBrush = new SolidColorBrush(Colors.Brown);

        private static TestBindingObject source;

        private static Border target;

        private Establish context = () =>
            {
                source = new TestBindingObject();
                target = new Border { DataContext = source };

                IObserver<Brush> toSource =
                    BindingFactory.CreateOneWayToSource<TestBindingObject, string, Brush>(o => o.BrushAsString);
                target.Bind(Border.BorderBrushProperty, toSource);
                target.Measure(Size.Empty);
            };

        private Because of = () => target.BorderBrush = expectedBrush;

        private It should_update_the_source = () => source.BrushAsString.ShouldEqual(expectedBrush.ToString());
    }

    [Subject(typeof(ReactiveObject), "One Way To Source")]
    public class when_a_one_way_to_source_binding_to_a_property_on_the_data_context_is_cleared
    {
        private static readonly Brush expectedBrush = new SolidColorBrush(Colors.Brown);

        private static TestBindingObject source;

        private static Border target;

        private Establish context = () =>
            {
                source = new TestBindingObject();
                target = new Border { DataContext = source };

                IObserver<Brush> toSource = BindingFactory.CreateOneWayToSource<TestBindingObject, Brush>(o => o.Brush);
                target.Bind(Border.BorderBrushProperty, toSource);
                target.Measure(Size.Empty);
            };

        private Because of = () =>
            {
                target.BorderBrush = expectedBrush;
                target.ClearBinding(Border.BorderBrushProperty);

                target.BorderBrush = new SolidColorBrush(Colors.Yellow);
            };

        private It should_not_update_the_source = () => source.Brush.ShouldEqual(expectedBrush);
    }

    [Subject(typeof(ReactiveObject), "One Way To Source")]
    public class when_there_is_a_one_way_to_source_binding_to_a_property_on_a_specified_source
    {
        private static readonly Brush expectedBrush = new SolidColorBrush(Colors.Brown);

        private static TestBindingObject source;

        private static Border target;

        private Establish context = () =>
            {
                source = new TestBindingObject();
                target = new Border();

                IObserver<Brush> toSource = BindingFactory.CreateOneWayToSource(source, o => o.Brush);
                target.Bind(Border.BorderBrushProperty, toSource);
            };

        private Because of = () => target.BorderBrush = expectedBrush;

        private It should_update_the_source = () => source.Brush.ShouldEqual(expectedBrush);
    }

    [Subject(typeof(ReactiveObject), "One Way To Source")]
    public class
        when_there_is_a_one_way_to_source_binding_to_a_property_on_a_specified_source_and_type_conversion_is_required
    {
        private static readonly Brush expectedBrush = new SolidColorBrush(Colors.Brown);

        private static TestBindingObject source;

        private static Border target;

        private Establish context = () =>
            {
                source = new TestBindingObject();
                target = new Border();

                IObserver<Brush> toSource = BindingFactory.CreateOneWayToSource<TestBindingObject, string, Brush>(
                    source, o => o.BrushAsString);
                target.Bind(Border.BorderBrushProperty, toSource);
            };

        private Because of = () => target.BorderBrush = expectedBrush;

        private It should_update_the_source = () => source.BrushAsString.ShouldEqual(expectedBrush.ToString());
    }

    [Subject(typeof(ReactiveObject), "One Way To Source")]
    public class when_a_one_way_to_source_binding_to_a_property_on_a_specified_source_is_cleared
    {
        private static readonly Brush expectedBrush = new SolidColorBrush(Colors.Brown);

        private static TestBindingObject source;

        private static Border target;

        private Establish context = () =>
            {
                source = new TestBindingObject();
                target = new Border();

                IObserver<Brush> toSource = BindingFactory.CreateOneWayToSource(source, o => o.Brush);
                target.Bind(Border.BorderBrushProperty, toSource);
            };

        private Because of = () =>
            {
                target.BorderBrush = expectedBrush;
                target.ClearBinding(Border.BorderBrushProperty);

                target.BorderBrush = new SolidColorBrush(Colors.Yellow);
            };

        private It should_not_update_the_source = () => source.Brush.ShouldEqual(expectedBrush);
    }

    [Subject(typeof(ReactiveObject), "One Way To Source")]
    public class when_there_is_a_one_way_to_source_binding_and_the_type_of_the_target_property_is_more_derived
    {
        private static readonly SolidColorBrush expectedBrush = new SolidColorBrush(Colors.Brown);

        private static TestBindingObject source;

        private static TestBindingReactiveObject target;

        private Establish context = () =>
            {
                source = new TestBindingObject();
                target = new TestBindingReactiveObject();

                IObserver<Brush> toSource = BindingFactory.CreateOneWayToSource(source, o => o.Brush);
                target.Bind(TestBindingReactiveObject.SolidColorBrushProperty, toSource);
            };

        private Because of = () => target.SolidColorBrush = expectedBrush;

        private It should_update_the_source = () => source.Brush.ShouldEqual(expectedBrush);
    }

    [Subject(typeof(ReactiveObject), "One Way To Source")]
    public class when_there_is_a_one_way_to_source_binding_and_the_type_of_the_source_property_is_more_derived
    {
        private static readonly SolidColorBrush expectedBrush = new SolidColorBrush(Colors.Brown);

        private static TestBindingObject source;

        private static Border target;

        private Establish context = () =>
            {
                source = new TestBindingObject();
                target = new Border();

                IObserver<Brush> toSource = BindingFactory.CreateOneWayToSource<TestBindingObject, Brush>(
                    source, o => o.SolidColorBrush);
                target.Bind(Border.BorderBrushProperty, toSource);
            };

        private Because of = () => target.BorderBrush = expectedBrush;

        private It should_update_the_source = () => source.SolidColorBrush.ShouldEqual(expectedBrush);
    }

    [Subject(typeof(ReactiveObject))]
    public class when_the_data_context_is_set_after_the_binding_has_been_created
    {
        private const string ExpectedValue = "Value";

        private static TextBlock target;

        private Establish context = () =>
            {
                target = new TextBlock(new Mock<ISpriteFont>().Object);
                IObservable<string> fromSource = BindingFactory.CreateOneWay<string>();
                target.Bind(TextBlock.TextProperty, fromSource);
                target.Measure(Size.Empty);
            };

        private Because of = () =>
            {
                target.DataContext = ExpectedValue;
                target.Measure(Size.Empty);
            };

        private It should_bind_to_the_data_context = () => target.Text.ShouldEqual(ExpectedValue);
    }

    [Subject(typeof(ReactiveObject))]
    public class when_binding_to_the_data_context_and_the_data_context_is_changed
    {
        private const string NewDataContext = "New Data Context";

        private static TextBlock target;

        private Establish context = () =>
            {
                target = new TextBlock(new Mock<ISpriteFont>().Object) { DataContext = "Old Data Context" };
                IObservable<string> fromSource = BindingFactory.CreateOneWay<string>();
                target.Bind(TextBlock.TextProperty, fromSource);
                target.Measure(Size.Empty);
            };

        private Because of = () =>
            {
                target.DataContext = NewDataContext;
                target.Measure(Size.Empty);
            };

        private It should_use_the_new_data_context = () => target.Text.ShouldEqual(NewDataContext);
    }

    [Subject(typeof(ReactiveObject))]
    public class when_binding_to_the_data_context_and_the_data_context_is_changed_to_null
    {
        private const string NewDataContext = null;

        private static TextBlock target;

        private Establish context = () =>
            {
                target = new TextBlock(new Mock<ISpriteFont>().Object) { DataContext = "Old Data Context" };
                IObservable<string> fromSource = BindingFactory.CreateOneWay<string>();
                target.Bind(TextBlock.TextProperty, fromSource);
                target.Measure(Size.Empty);
            };

        private Because of = () =>
            {
                target.DataContext = NewDataContext;
                target.Measure(Size.Empty);
            };

        private It should_use_the_new_data_context = () => target.Text.ShouldEqual(NewDataContext);
    }
}
